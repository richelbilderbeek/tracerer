#' Parses a BEAST2 .trees output file
#' @param filename name of the BEAST2 .trees output file
#' @return the phylogenies in the posterior
#' @export
#' @examples
#'   trees_filename <- get_tracerer_path("beast2_example_output.trees")
#'   posterior <- parse_beast_trees(trees_filename)
#'   testit::assert(is_trees_posterior(posterior))
#' @author Richel J.C. Bilderbeek
parse_beast_trees <- function(
  filename
) {

  if (!file.exists(filename)) {
    stop(
      "'filename' is the name of an absent file. ",
      "Filename '", filename, "' not found"
    )
  }

  trees <- tryCatch({
      parse_beast_trees_impl_2(filename)
    },
    error = function(cond) {
      stop("invalid file")
    }
  )

  testit::assert(length(trees) != 1 || !is.na(trees))


  class(trees) <- "multiPhylo"
  trees
}

#' Parses a BEAST2 .trees output file
#' @param filename name of the BEAST2 .trees output file
#' @return the phylogenies in the posterior
#' @export
#' @examples
#'   trees_filename <- get_tracerer_path("beast2_example_output.trees")
#'   posterior <- parse_beast_trees(trees_filename)
#'   testit::assert(is_trees_posterior(posterior))
#' @author Richel J.C. Bilderbeek
#' @noRd
parse_beast_trees_impl_2 <- function(
  filename
) {
  beast2out.read.trees(filename)
}


#' Extract a list of phylogenies from a BEAST2 posterior file
#' @param file name of the BEAST2 posterior filename, usually ends with '.trees'
#' @param opt.rescale.edge.length Rescaling factor of the phylogenies,
#'   a value of 1.0 denotes that the original edge lengths are maintained
#' @param opt.burnin how many phylogenies to discard, an value of will keep all trees
#' @return a list of phylogenies of type 'phylo'
#' @examples
#'   trees_file <- "vignettes/example.trees"
#'   testit::assert(file.exists(trees_file))
#'   posterior <- beast2out.read.trees(trees_file)
#'   testit::assert(length(posterior) == 10)
#'   testit::assert(class(posterior[[1]]) == "phylo")
#' @export
#' @author Oliver Ratmann
#' @noRd
beast2out.read.trees <- function(
  file,
  opt.rescale.edge.length= 1.,
  opt.burnin=0
)
{
	tmp			<- readLines(file, n=2e3, warn = FALSE)
	tmp			<- which( grepl('#NEXUS', tmp) )
	if(length(tmp)>1)
	{
		cat(paste('\nFound #NEXUS headers, n=',length(tmp),'.\nDiscard all lines before last entry on line', tail(tmp,1)))
		cmd		<- paste('sed -i".bak" 1,',tail(tmp,1)-1,'d ', file, sep='')
		system(cmd)
		cmd		<- paste('sed -i".bak2" 1s/\\;// ', file, sep='')
		system(cmd)
		cmd		<- list.files(paste(rev(rev(strsplit(file, '/')[[1]])[-1]),collapse='/'), pattern='*bak*', full.names=TRUE)
		cat(paste('\nrm files\n', paste(cmd, collapse='\n')))
		file.remove(cmd)
	}
	mph			<- ape::read.nexus(file)
	#	remove burn in
	tmp			<- regexpr('[0-9]+',names(mph))
	if(any(tmp<0))	stop('unexpected nexus file without STATE iteration numbers')
	mph.it		<- as.numeric( regmatches( names(mph), tmp) )
	mph			<- lapply( which( mph.it>opt.burnin), function(j)	mph[[j]]	)
	mph.it		<- mph.it[ mph.it > opt.burnin ]
	names(mph)	<- paste('STATE_',mph.it,sep='')
	#	rescale edge lengths
	if(opt.rescale.edge.length!=1.)
		for(j in seq_along(mph))
			mph[[j]]$edge.length	<- mph[[j]]$edge.length * opt.rescale.edge.length
	mph
}
